* prometheus
** prometheus 高可用
   可通过 deployment 和 DaementSet 方式实现高可用
*** deployment
    1. kubectl create -f prometheus-configmap.yaml
    2. kubectl create -f prometheus-config-rule.yaml
    3. kubectl create -f prometheus-deploy.yaml #其中 spec->replicas > 1
    4. kubectl create -f prometheus-service.yaml # service.spec.sessionAffinity 设置为 “ClientIP”
    执行以上操作后，通过访问 http://masterIP:30900／targets 进入 targets 监控见面，查看 target 的 State 是否为
    UP 状态，假如都为 UP，这时即可到 prometheus 总览界面查询所需要的数据。


*** daemonSet 方式
    1. kubectl create -f  prometheus-configmap.yaml
    2. kubectl create -f prometheus-config-rule.yaml
    3. kubectl create -f prometheus-daemonset.yaml
    4. kubectl create -f prometheus-service.yaml  # service.spec.sessionAffinity 设置为 "ClientIP"
    执行以上操作后，通过访问 http://masterIP:30900／targets 进入 targets 监控见面，查看 target 的 State 是否为
    UP 状态，假如都为 UP，这时即可到 prometheus 总览界面查询所需要的数据。


*** 支持 Node 上的磁盘 IO，网络吞吐等监控
    - 目前默认支持的功能：https://github.com/prometheus/node_exporter#enabled-by-default
    - 默认 diable 的功能：https://github.com/prometheus/node_exporter#disabled-by-default
    - node-exporter 使用 daemonSet 方式启动，配置文件见附录
    - kubectl create -f ./prometheus-node-exporter.yaml
*** 调优
**** 内存调优
     https://prometheus.io/docs/operating/storage/
     v1.6 以后 Prometheus keeps all the currently used chunks in memory. In addition, it keeps as many most
  recently used chunks in memory as possible. You have to tell Prometheus how much memory it may use for this
  caching. The flag storage.local.target-heap-size allows you to set the heap size (in bytes) Prometheus aims
  not to exceed.
  As a rule of thumb, you should have at least 50% headroom in physical memory over the configured heap size.
  (Or, in other words, set storage.local.target-heap-size to a value of two thirds of the physical memory
  limit Prometheus should not exceed.)

  使用  storage.local.target-heap-size 进行内存设置，如果一个节点专门用来运行 Prometheus，设置为总的物理内存的
  2/3，如果有其他组件，适当估计其他组件损耗，使用剩余内存的  2/3 即可。
  1.6 之前的版本参考以上文档
**** 块编码调优
      Prometheus currently offers three different types of chunk encodings. The chunk encoding for newly
     created chunks is determined by the -storage.local.chunk-encoding-version flag. The valid values are 0,
     1, or 2.
     Type 0 is the simple delta encoding implemented for Prometheus's first chunked storage layer. Type 1 is the
     current default encoding, a double-delta encoding with much better compression behavior than type 0.

      https://prometheus.io/blog/2016/05/08/when-to-use-varbit-chunks/Type
      2 有更好的压缩比，但是会需要更多的 CPU 资源，IO 瓶颈时可以考虑使用  Type  2
      Three times more samples in RAM, three times more samples on disk, only a third of disk ops, and since disk
      ops are currently the bottleneck for ingestion speed, it will also allow ingestion to be three times faster.
      In fact, the recently reported new ingestion record of 800,000 samples per second was only possible with
      varbit chunks – and with an SSD, obviously. With spinning disks, the bottleneck is reached far earlier, and
      thus the 3x gain matters even more.
    3. 如果碰到 prometheus 的 apiserver endpoint UnKnown
    增加 prometheus 内存再试试
    其他调优、调试参数参考：https://prometheus.io/docs/operating/storage/ 最下方





** 常见问题以及解决方式
